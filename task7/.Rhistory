```
Kaip matome vid prognozė stengiasi sumažinti vidutinę paklaidą (ME), tačiau kyla kitų paklaidų dydis. Snaive prognozei pavyksta gerai atspėti kita sezoną, šios prognozės paklaidos mažiausios. Drift prognozėje atsižvelgiama į trend
Manau pagal MPE nereikėtų rinktis modelio, nes šis rodiklis labiau aptinka paslinktumą, nes ne absoliučios reikšmės skaičiuojamos. Geriau naudoti MAPE rodiklį, nes ima absoliučius dydžius. Taigi naudingi rodikliai MAE: Mean Absolute Error, MAPE: Mean Absolute Percentage Error, RMSE - Root Mean Squared Error, MASE: Mean Absolute Scaled Error, ACF1: Autocorrelation of errors at lag 1.
(e) Which method does best? Why?
Štai minėti rodikliai, tinkantys vertinant prognozes:
```{r}
acf(bricksq)                            #kas keturis pikas, nurodantis metinį ketverčio sezoniškumą
```
vid prognozės rodikliai:
```{r}
kable(accuracy(vid,bricks2)[,c(2,3,5,6,7)])
```
naive prognozės rodikliai:
```{r}
kable(accuracy(naive,bricks2)[,c(2,3,5,6,7)])
```
snaive prognozės rodikliai:
```{r}
kable(accuracy(snaive,bricks2)[,c(2,3,5,6,7)])
```
drift prognozės rodikliai:
```{r}
kable(accuracy(drift,bricks2)[,c(2,3,5,6,7)])
```
Manau pagal MPE nereikėtų rinktis modelio, nes šis rodiklis labiau aptinka paslinktumą, nes ne absoliučios reikšmės skaičiuojamos. Geriau naudoti MAPE rodiklį, nes ima absoliučius dydžius. Taigi naudingi rodikliai MAE: Mean Absolute Error, MAPE: Mean Absolute Percentage Error, RMSE - Root Mean Squared Error, MASE: Mean Absolute Scaled Error, ACF1: Autocorrelation of errors at lag 1.
Tikrai galime atmesti vidurkio metodą, nes jų paklaidos daug didesnės nei kitų modelių. Matome, kad geriausiai testuojamuose duomenyse pasirodė snaive metodas. Taip pat galime tarti, kad jis geresnis už paprastą naive metodą, nes snaive yra toks pat kaip naive, tik kad snaive dar atsižvelgiama į sezoniškumą, kuris buvo paskutinis duomenyse. Renkankantis tarp snaive ir drift modelių,
pagal duomenis, galime manyti, kad ir ateityje panašus sezoniškumas gali atsikartoti, todėl snaive gan gerai prognozuotų lyginant su drift metodu (snaive būtent ir ima paskutinį sezoną kaip prognozę). O drift tinktų labiau už snaive, jei trendas būtų svarbiau už sezoniškumą, bet pagal paskutinius duomenis sezoniškumas yra svarbesnis, todėl renkuosi kaip geriausią modelį snaive.
(f) For the best method, compute the residuals and plot them.
Kaip matome yra dėsningumas tarp paklaidų. Jos koreliuoja, taigi nėra pats geriausias modelis, tačiau iš vertintų - geriausias.
```{r}
snaive=snaive(bricksq)
res <- residuals(snaive)
plot(res)
```
Do the residuals appear to be uncorrelated and normally dis-
tributed?
Paklaidos koreliuotos ir neturi normaliojo skirstinio:
```{r}
hist(res, breaks="FD")
Acf(res)
shapiro.test(res)  #atmetame H0 hipotezę, jog paklaidos normaliosios. Paklaidos neturi normaliojo skirstinio
kable(accuracy(vid,bricks2))
kable(accuracy(naive,bricks2))
kable(accuracy(snaive,bricks2))
kable(accuracy(drift,bricks2))
kable(accuracy(snaive,bricks2))
kable(accuracy(drift,bricks2))
kable(accuracy(vid,bricks2))
kable(accuracy(naive,bricks2))
kable(accuracy(snaive,bricks2))
ibrary(fpp)
library(knitr)
```
(a) Produce some plots of the data in order to become familiar
with it.
Matomas metinis sezoniškumas (kas 12 lag'ų), matomi ciklai, nėra trendo.
```{r}
tsdisplay(hsales, plot.type="scatter")
```
``{r}
data1 <- window(hsales, end=1993.99)    #duomenų padalinimas į du time series
data2 <- window(hsales, start=1994)
```
``{r}
data1 <- window(hsales, end=1993.99)    #duomenų padalinimas į du time series
data2 <- window(hsales, start=1994)
```
vid <- meanf(data1, h=20)               # prognozė, lygi duomenų vidurkiui
plot(vid)
vid <- meanf(data1, h=20)               # prognozė, lygi duomenų vidurkiui
plot(vid)
naive <- naive(data1, h=20)             # prognozė, kuri atsižvelgia tik į paskutinę duomenų reikšmę
plot(naive)
snaive <- snaive(data1, h=20)           # preitas užfiksuotas sezonas yra naudojamas prognozuoti ateitį
plot(snaive)
drift <- rwf(data1, drift=TRUE, h=20)   # atsižvelgia į paskutinę duomenų reikšmę ir prideda vidutinį svyravimą
plot(drift)                             # vidutinis svyravimas yra mažai nutolęs nuo 0, taigi beveik sutampa su naive prognoze
kable(accuracy(vid,data2)[,c(2,3,5,6,7)])
kable(accuracy(naive,data2)[,c(2,3,5,6,7)])
kable(accuracy(snaive,data2)[,c(2,3,5,6,7)])
kable(accuracy(drift,data2)[,c(2,3,5,6,7)])
data1 <- window(hsales, end=1993.99)    #duomenų padalinimas į du time series
data2 <- window(hsales, start=1994)
tsdisplay(hsales, plot.type="scatter")
legend
?legend
plot(hsales)
lines(data1,col="red")
lines(data2,col="blue")
legend("topleft",col = c("BLACK","BLUE"),pch=1,bty="n" )
legend("topleft",col = c("BLACK","BLUE"),pch=1,bty="n" )
```
lines(data2,col="blue")
legend("topleft",legend= "liekanos",col = c("BLACK","BLUE"),pch=1,bty="n" )
legend("topleft",legend= "liekanos",col = c("BLACK","BLUE"),pch=2,bty="n" )
?pch
legend("topleft",legend= ("iki 1994", "nuo 1994"),col = c("BLACK","BLUE"),lty=2)
plot(hsales)
lines(data1,col="red")
lines(data2,col="blue")
legend("topleft",legend= ("iki 1994", "nuo 1994"),col = c("BLACK","BLUE"),lty=2)
legend("topleft",legend= c("iki 1994", "nuo 1994"),col = c("BLACK","BLUE"),lty=2)
legend("topleft",legend= c("iki 1994", "nuo 1994"),col = c("RED","BLUE"),lty=2)
legend("topleft",legend= c("iki 1994", "nuo 1994"),col = c("RED","BLUE"),lty=1)
---
title: "Task7 - 5"
author: "Paulius Kostickis"
date: "Wednesday, April 13, 2016"
output: html_document
---
5. Consider the sales of new one-family houses in the USA (Jan 1987 –
Nov 1995). Data set: hsales.
```{r,include=FALSE}
library(fpp)
library(knitr)
```
(a) Produce some plots of the data in order to become familiar
with it.
Matomas metinis sezoniškumas (kas 12 lag'ų), matomi ciklai, nėra trendo.
```{r}
tsdisplay(hsales, plot.type="scatter")
```
(b) Split the data into a training set and a test set, where the test
set is the last two years of data.
```{r}
data1 <- window(hsales, end=1993.99)    #duomenų padalinimas į du time series
data2 <- window(hsales, start=1994)
```
Šių duomenų grafikas:
```{r}
plot(hsales)
lines(data1,col="red")
lines(data2,col="blue")
legend("topleft",legend= c("iki 1994", "nuo 1994"),col = c("RED","BLUE"),lty=1)
```
(c) Try various benchmark methods to forecast the training set and
compare the results on the test set. Which method did best?
Naudosime paprasčiausius modelius: mean, naive, snaive ir drift:
```{r}
vid <- meanf(data1, h=20)               # prognozė, lygi duomenų vidurkiui
plot(vid)
naive <- naive(data1, h=20)             # prognozė, kuri atsižvelgia tik į paskutinę duomenų reikšmę
plot(naive)
snaive <- snaive(data1, h=20)           # preitas užfiksuotas sezonas yra naudojamas prognozuoti ateitį
plot(snaive)
drift <- rwf(data1, drift=TRUE, h=20)   # atsižvelgia į paskutinę duomenų reikšmę ir prideda vidutinį svyravimą
plot(drift)                             # vidutinis svyravimas yra mažai nutolęs nuo 0, taigi beveik sutampa su naive prognoze
```
Lyginsime jų gebėjimą prognozuoti (žiurėsiu tik naudingiausius rodiklius):
vid prognozės rodikliai:
```{r}
kable(accuracy(vid,data2)[,c(2,3,5,6,7)])
```
naive prognozės rodikliai:
```{r}
kable(accuracy(naive,data2)[,c(2,3,5,6,7)])
```
snaive prognozės rodikliai:
```{r}
kable(accuracy(snaive,data2)[,c(2,3,5,6,7)])
```
drift prognozės rodikliai:
```{r}
kable(accuracy(drift,data2)[,c(2,3,5,6,7)])
```
RMSE: Root Mean Squared Error, MAE: Mean Absolute Error, MAPE: Mean Absolute Percentage Error, MASE: Mean Absolute Scaled Error, ACF1: Autocorrelation of errors at lag 1.
(d) For the best method, compute the residuals and plot them.
What do the plots tell you?
(e) Can you invent a better forecasting method than any of the
benchmark methods for these data?
kable(accuracy(vid,data2)[,c(2,3,5,6,7)])
kable(accuracy(naive,data2)[,c(2,3,5,6,7)])
kable(accuracy(naive,data2)[,c(2,3,5,6,7)])
kable(accuracy(snaive,data2)[,c(2,3,5,6,7)])
kable(accuracy(vid,data2)[,c(2,3,5,6,7)])
plot(drift)                             # vidutinis svyravimas yra mažai nutolęs nuo 0, taigi beveik sutampa su naive prognoze
plot(snaive)
plot(naive)
snaive <- snaive(data1, h=20)           # preitas užfiksuotas sezonas yra naudojamas prognozuoti ateitį
plot(snaive)
plot(hsales)
lines(data1,col="red")
lines(data2,col="blue")
acf(hsales)                            #kas keturis pikas, nurodantis metinį ketverčio sezoniškumą
kable(accuracy(naive,data2)[,c(2,3,5,6,7)])
kable(accuracy(snaive,data2)[,c(2,3,5,6,7)])
data1 <- window(hsales, end=1993.99)    #duomenų padalinimas į du time series
data2 <- window(hsales, start=1994)
```
plot(hsales)
lines(data1,col="red")
lines(data2,col="blue")
kable(accuracy(drift,data2)[,c(2,3,5,6,7)])
kable(accuracy(snaive,data2)[,c(2,3,5,6,7)])
kable(accuracy(vid,data2)[,c(2,3,5,6,7)])
kable(accuracy(drift,data2)[,c(2,3,5,6,7)])
kable(accuracy(vid,data2)[,c(2,3,5,6,7)])
kable(accuracy(snaive,data2)[,c(2,3,5,6,7)])
snaive=snaive(bricksq)
snaive <- snaive(data1, h=20)           # preitas užfiksuotas sezonas yra naudojamas prognozuoti ateitį
snaive=snaive(hsales)
res <- residuals(snaive)
plot(res)
afc(res)
acf(res)
res <- residuals(snaive)
acf(res)
res <- residuals(snaive)
plot(res)
Acf(res)
shapiro.test(res)  #atmetame H0 hipotezę, jog paklaidos yra baltas triukšmas.
hist(res, breaks="FD")
Acf(res)
acf(res)
Acf(res)
Acf(hsales)
Acf(res)
snaive=snaive(data2)
res <- residuals(snaive)
Acf(res)
plot(res)
snaive=snaive(data2)
res <- residuals(snaive)
Acf(res)
plot(res)
```
snaive=snaive(data2)
res <- residuals(snaive)
plot(bricksq)
lines(bricks1,col="red")
lines(bricks2,col="blue")
plot(bricksq)
lines(bricks1,col="red")
bricks1 <- window(bricksq, end=1987.99)
bricks2 <- window(bricksq, start=1988)
lines(bricks1,col="red")
lines(bricks2,col="blue")
kable(accuracy(snaive,data2)[,c(2,3,5,6,7)])
kable(accuracy(naive,data2)[,c(2,3,5,6,7)])
5. Consider the sales of new one-family houses in the USA (Jan 1987 –
Nov 1995). Data set: hsales.
```{r,include=FALSE}
library(fpp)
library(knitr)
```
(a) Produce some plots of the data in order to become familiar
with it.
Matomas metinis sezoniškumas (kas 12 lag'ų), matomi ciklai, nėra trendo.
```{r}
tsdisplay(hsales, plot.type="scatter")
```
(b) Split the data into a training set and a test set, where the test
set is the last two years of data.
```{r}
data1 <- window(hsales, end=1993.99)    #duomenų padalinimas į du time series
data2 <- window(hsales, start=1994)
```
Šių duomenų grafikas:
```{r}
plot(hsales)
lines(data1,col="red")
lines(data2,col="blue")
legend("topleft",legend= c("iki 1994", "nuo 1994"),col = c("RED","BLUE"),lty=1)
```
(c) Try various benchmark methods to forecast the training set and
compare the results on the test set. Which method did best?
vid <- meanf(data1, h=20)               # prognozė, lygi duomenų vidurkiui
plot(vid)
naive <- naive(data1, h=20)             # prognozė, kuri atsižvelgia tik į paskutinę duomenų reikšmę
plot(naive)
snaive <- snaive(data1, h=20)           # preitas užfiksuotas sezonas yra naudojamas prognozuoti ateitį
plot(snaive)
drift <- rwf(data1, drift=TRUE, h=20)   # atsižvelgia į paskutinę duomenų reikšmę ir prideda vidutinį svyravimą
plot(drift)                             # vidutinis svyravimas yra mažai nutolęs nuo 0, taigi beveik sutampa su naive prognoze
```
Matomas metinis sezoniškumas (pikas kas 12 lag'ų):
```{r}
Acf(hsales)
```
Lyginsime metodų gebėjimą prognozuoti (žiurėsiu tik naudingiausius rodiklius):
vid prognozės rodikliai:
```{r}
kable(accuracy(vid,data2)[,c(2,3,5,6,7)])
kable(accuracy(naive,data2)[,c(2,3,5,6,7)])
kable(accuracy(vid,data2)[,c(2,3,5,6,7)])
kable(accuracy(drift,data2)[,c(2,3,5,6,7)])
kable(accuracy(naive,data2)[,c(2,3,5,6,7)])
kable(accuracy(snaive,data2)[,c(2,3,5,6,7)])
```{r}
kable(accuracy(naive,data2)[,c(2,3,5,6,7)])
```
snaive prognozės rodikliai:
```{r}
kable(accuracy(snaive,data2)[,c(2,3,5,6,7)])
```
Šiuo atveju, snaive galbūt gerai atspėja sezoniškumą, kuris atsikartoja (sezonai mažai skiriasi nuo preito laikotario sezono). Tai šiuo atveju rinkčiausi snaive kaip geresnį metodą vietoj naive žiūrint į grafikus:
plot(hsales)
lines(data1,col="red")
lines(data2,col="blue")
legend("topleft",legend= c("iki 1994", "nuo 1994"),col = c("RED","BLUE"),lty=1)
par=(mfrows=c(1,3))
plot(hsales)
lines(data1,col="red")
lines(data2,col="blue")
legend("topleft",legend= c("iki 1994", "nuo 1994"),col = c("RED","BLUE"),lty=1)
plot(naive)
plot(snaive)
par=(mfrows=c(1,3))
plot(hsales)
lines(data1,col="red")
lines(data2,col="blue")
legend("topleft",legend= c("iki 1994", "nuo 1994"),col = c("RED","BLUE"),lty=1)
plot(naive)
par=(mfrows=c(2,2))
plot(hsales)
lines(data1,col="red")
lines(data2,col="blue")
legend("topleft",legend= c("iki 1994", "nuo 1994"),col = c("RED","BLUE"),lty=1)
plot(naive)
?par
par=(mfrows=c(2,1))
plot(hsales)
lines(data1,col="red")
lines(data2,col="blue")
legend("topleft",legend= c("iki 1994", "nuo 1994"),col = c("RED","BLUE"),lty=1)
plot(naive)
par=(mfrows=c(1,3))
plot(hsales)
plot(naive)
plot(snaive)
par=(mfrows=c(1,3))
par(mfrow=c(2,2))
plot(hsales)
par(mfrow=c(1,3))
plot(hsales)
par(mfrow=c(1,3))
par(mfrow=c(1,3))
plot(hsales)
lines(data1,col="red")
lines(data2,col="blue")
legend("topleft",legend= c("iki 1994", "nuo 1994"),col = c("RED","BLUE"),lty=1)
plot(naive)
plot(snaive)
par(mfrow=c(1,2))
plot(hsales)
lines(data1,col="red")
lines(data2,col="blue")
legend("topleft",legend= c("iki 1994", "nuo 1994"),col = c("RED","BLUE"),lty=1)
plot(naive)
plot(snaive)
kable(accuracy(vid,data2)[,c(2,3,5,6,7)])
kable(accuracy(snaive,data2)[,c(2,3,5,6,7)])
```
Acf(hsales)
dritft=drift(hsales)
res <- residuals(drift)
dritf=rwf(hsales, drift=TRUE)
res <- residuals(drift)
Acf(res)
plot(res)
hist(res, breaks="FD")
Acf(res)
shapiro.test(res)  #atmetame H0 hipotezę, jog paklaidos yra baltas triukšmas.
dritf=rwf(hsales, drift=TRUE)
res <- residuals(drift)
Acf(res)
plot(res)
hist(res, breaks="FD")
Acf(res)
shapiro.test(res)  #atmetame H0 hipotezę, jog paklaidos yra baltas triukšmas.
---
title: "Task7 - 5"
author: "Paulius Kostickis"
date: "Wednesday, April 13, 2016"
output: html_document
---
5. Consider the sales of new one-family houses in the USA (Jan 1987 –
Nov 1995). Data set: hsales.
```{r,include=FALSE}
library(fpp)
library(knitr)
```
(a) Produce some plots of the data in order to become familiar
with it.
Matomas metinis sezoniškumas (kas 12 lag'ų), matomi ciklai, nėra trendo.
```{r}
tsdisplay(hsales, plot.type="scatter")
```
(b) Split the data into a training set and a test set, where the test
set is the last two years of data.
```{r}
data1 <- window(hsales, end=1993.99)    #duomenų padalinimas į du time series
data2 <- window(hsales, start=1994)
```
Šių duomenų grafikas:
```{r}
plot(hsales)
lines(data1,col="red")
lines(data2,col="blue")
legend("topleft",legend= c("iki 1994", "nuo 1994"),col = c("RED","BLUE"),lty=1)
```
(c) Try various benchmark methods to forecast the training set and
compare the results on the test set. Which method did best?
Naudosime paprasčiausius modelius: mean, naive, snaive ir drift:
```{r}
vid <- meanf(data1, h=20)               # prognozė, lygi duomenų vidurkiui
plot(vid)
naive <- naive(data1, h=20)             # prognozė, kuri atsižvelgia tik į paskutinę duomenų reikšmę
plot(naive)
snaive <- snaive(data1, h=20)           # preitas užfiksuotas sezonas yra naudojamas prognozuoti ateitį
plot(snaive)
drift <- rwf(data1, drift=TRUE, h=20)   # atsižvelgia į paskutinę duomenų reikšmę ir prideda vidutinį svyravimą
plot(drift)                             # vidutinis svyravimas yra mažai nutolęs nuo 0, taigi beveik sutampa su naive prognoze
```
Matomas metinis sezoniškumas (pikas kas 12 lag'ų):
```{r}
Acf(hsales)
```
vid prognozės rodikliai:
```{r}
kable(accuracy(vid,data2)[,c(2,3,5,6,7)])
```
drif prognozės rodikliai:
```{r}
kable(accuracy(drift,data2)[,c(2,3,5,6,7)])
```
Drift metodas pasirodė geriau už vid training duomenyse, tačiau test duomenyse - vid metodas. Kadangi test duomenų labai mažai, manytina, jog pagal training duomenis geriau rinktis metodą šiuo atveju.
Šiuo atveju, snaive galbūt atspės sezoniškumą, tačiau galime matyti, kad preiti sezonai buvo labai skirtingi negu paskutinysis (žiurint į grafikus). Tačiau šiuo atveju rinkčiausi snaive kaip geresnį metodą vietoj naive, nes gerai atspėjo paskutiniusduomenis:
```{r}
par(mfrow=c(1,2))
plot(hsales)
lines(data1,col="red")
lines(data2,col="blue")
legend("topleft",legend= c("iki 1994", "nuo 1994"),col = c("RED","BLUE"),lty=1)
plot(naive)
plot(hsales)
lines(data1,col="red")
lines(data2,col="blue")
legend("topleft",legend= c("iki 1994", "nuo 1994"),col = c("RED","BLUE"),lty=1)
plot(snaive)
```
Tačiau šiuo atveju rinkčiausi snaive kaip geresnį metodą vietoj naive, nes gerai atspėjo paskutiniusduomenis(žiūrint į test duomenis):
naive prognozės rodikliai:
```{r}
kable(accuracy(naive,data2)[,c(2,3,5,6,7)])
```
snaive prognozės rodikliai:
```{r}
kable(accuracy(snaive,data2)[,c(2,3,5,6,7)])
```
Lyginam drift ir snaive metodus:
vid prognozės rodikliai:
```{r}
kable(accuracy(vid,data2)[,c(2,3,5,6,7)])
```
snaive prognozės rodikliai:
```{r}
kable(accuracy(snaive,data2)[,c(2,3,5,6,7)])
```
Snaive pasirodė geriau negu vid metodas testuojamuose duomenyse ir galbūt gali gerai atspėti būsimą sezoniškumą netolimoj ateityje (nors ankstesniuose duomenyse sezono metu įgautos reikšmės smarkiai skyrėsi), tai jei reikia prognozuoti trumpą laikotarpį, rinkčiausi snaive metodą. Tačiau jeigu reiktų rinktis ilgam laikotarpiui metodą, rinkčiausi drift metodą, nes jo prognozė remiasi visais praeities duomenimis ir atsparesnis ciklams, kurie yra akivaizdūs.
RMSE: Root Mean Squared Error, MAE: Mean Absolute Error, MAPE: Mean Absolute Percentage Error, MASE: Mean Absolute Scaled Error, ACF1: Autocorrelation of errors at lag 1.
(d) For the best method, compute the residuals and plot them.
What do the plots tell you?
Šiuo atveju reikia metodo ilgam laikotarpiui, tad pasirinksiu drift metodą kaip geriausią.
Kaip matome yra dėsningumas tarp paklaidų. Jos koreliuoja ir nėra baltas triukšmas, taigi nėra pats geriausias modelis, tačiau iš vertintų - geriausias prognozuojant naujausius duomenis:
res <- residuals(drift)
Acf(res)
plot(res)
hist(res, breaks="FD")
Acf(res)
shapiro.test(res)  #atmetame H0 hipotezę, jog paklaidos yra baltas triukšmas.
dritf=rwf(hsales, drift=TRUE)
res <- residuals(drift)
Acf(res)
plot(res)
hist(res, breaks="FD")
Acf(res)
Acf(res)                 # paklaidos yra koreliuotos
plot(res)
hist(res, breaks="FD")   # atrodo kaip normalusis skirtstinys
Acf(res)
shapiro.test(res)  #neatmetame H0 hipotezę, jog paklaidos yra baltas triukšmas.
dritf=rwf(hsales, drift=TRUE)
res <- residuals(drift)
Acf(res)                 # paklaidos yra koreliuotos
plot(res)
hist(res, breaks="FD")   # atrodo kaip normalusis skirtstinys
Acf(res)
shapiro.test(res)  #neatmetame H0 hipotezę, jog paklaidos yra baltas triukšmas.
Acf(res)
kable(accuracy(vid,data2)[,c(2,3,5,6,7)])
kable(accuracy(snaive,data2)[,c(2,3,5,6,7)])
kable(accuracy(snaive,data2)[,c(2,3,5,6,7)])
kable(accuracy(drift,data2)[,c(2,3,5,6,7)])
kable(accuracy(snaive,data2)[,c(2,3,5,6,7)])
kable(accuracy(snaive,data2)[,c(2,3,5,6,7)])
kable(accuracy(naive,data2)[,c(2,3,5,6,7)])
kable(accuracy(drift,data2)[,c(2,3,5,6,7)])
```
snaive prognozės rodikliai:
```{r}
kable(accuracy(naive,data2)[,c(2,3,5,6,7)])
kable(accuracy(drift,data2)[,c(2,3,5,6,7)])
kable(accuracy(naive,data2)[,c(2,3,5,6,7)])
kable(accuracy(snaive,data2)[,c(2,3,5,6,7)])
res <- residuals(naive)
Acf(res)                 # paklaidos yra koreliuotos
Acf(res)                 # paklaidos yra koreliuotos
plot(res)                # matosi šioks toks dėsningumas, nėra baltas triukšmas
hist(res, breaks="FD")   # atrodo kaip normalusis skirtstinys
Acf(res)                 # koreliuotos paklaidos
shapiro.test(res)        # neatmetame H0 hipotezę, jog paklaidos normaliosios.
