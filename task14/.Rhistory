?adf.test
library(fpp)
library(knitr)
?adf.test
data=wmurders
tsdisplay(data, plot.type="scatter")
auto.arima(data)
nd=ndiffs(data)
diffdata <- diff(data,differences=nd)
plot(diffdata)
kpss.test(diffdata)  # p-vaule > 0.05 H0 neatmetame, kad duomenys stacionarūs.
par(mfrow=c(1,2))
pacf(diffdata)
acf(diffdata)
?arima
nd=ndiffs(data)
nd
par(mfrow=c(1,2))
pacf(diffdata)
acf(diffdata)
a)
acf(data
pacf(data)
pacf(data)
acf(data)
pacf(diffdata)
acf(diffdata)
arima(data,c(5,2,0))
pacf(diffdata)
acf(diffdata)
arima(data,c(5,2,0))
mod3=arima(data,c(5,2,1))
mod4=arima(data,c(4,2,0))
mod3
mod4
mod2
mod2=arima(data,c(5,2,0))
mod2
mod1
mod1=auto.arima(data)
mod1
accuracy(mod1)
accuracy(mod2)
accuracy(mod3)
accuracy(mod4)
mod5=arima(data,c(3,2,0))
accuracy(mod5)
accuracy(mod2)
accuracy(mod1)
accuracy(mod2)
accuracy(mod3)
accuracy(mod4)
accuracy(mod5)
mod5=arima(data,c(4,2,1))
accuracy(mod5)
accuracy(mod3)
mod6=arima(data,c(5,2,0))
accuracy(mod6)
accuracy(mod3)
accuracy(mod1)
accuracy(mod2)
accuracy(mod3)
accuracy(mod4)
accuracy(mod5)
mod5=arima(data,c(5,2,0))
accuracy(mod1)
accuracy(mod2)
accuracy(mod3)
accuracy(mod4)
accuracy(mod5)
kable(accuracy(mod5))
Box.test(mod3$res, type="Lj")
Box.test(mod3$res, type="Lj")
mean(mod3$res)
shapiro.test(mod3$res)
?shapiro.test
plot(forecast(mod3))
plot(forecast(mod1))
plot(forecast(mod2))
data=wmurders
?wmurders
modETS=ets(wmurders)
modETS
test
Box.test(mod3$res, type="Lj")   # p > 0.05, H0 neatmetamas, kad liekanos nekoreliuotos
mean(mod3$res)                  # vidurkis labai arti 0
shapiro.test(mod3$res)          # galime neatmesti H0, nes p > 0.05, liekanos normaliojo skirstinio
modETS=ets(wmurders)
Box.test(modETS$res, type="Lj")   # p > 0.05, H0 neatmetamas, kad liekanos nekoreliuotos
mean(modETS$res)                  # vidurkis labai arti 0
Box.test(modETS$res, type="Lj")   # p > 0.05, H0 neatmetamas, kad liekanos nekoreliuotos
mean(modETS$res)                  # vidurkis labai arti 0
shapiro.test(modETS$res)          # galime neatmesti H0, nes p > 0.05, liekanos normaliojo skirstinio
modETS=ets(wmurders)
modETS
accuracy(mod3)
accuracy(modETS)
kable(accuracy(mod3))
kable(accuracy(modETS))
?usgdp
library(fpp)
library(knitr)
?usgdp
data=usgdp
tsdisplay(data, plot.type="scatter")
auto.arima(data)
data=usgdp
auto.arima(data)
nd=ndiffs(data)
diffdata <- diff(data,differences=nd)
nd
m
m
par(mfrow=c(1,2))
pacf(diffdata)
acf(diffdata)
mod2=arima(data,c(14,2,0))
mod2=arima(data,c(14,2,0))
mod2
mod1
mod1=auto.arima(data)
mod1
mod2
mod1
mod3=arima(data,c(13,2,0))
mod4=arima(data,c(15,2,0))
mod3
mod4
mod5
mod5=arima(data,c(14,2,1))
mod5
mod4
mod3
mod2
mod1
mod4=arima(data,c(15,2,0))
mod4
mod6=arima(data,c(15,2,1))
mod6
mod5
mod7=arima(data,c(16,2,1))
mod7
mod7=arima(data,c(15,2,2))
mod7
mod6
mod7
mod4=arima(data,c(4,2,0))
mod5
mod5
mod3
mod4
mod3
mod5
mod2
data=wmurders
tsdisplay(data, plot.type="scatter")
mod1=auto.arima(data)
nd=ndiffs(data)
diffdata <- diff(data,differences=nd)
mod2=arima(data,c(5,2,0))
mod2
mod3=arima(data,c(5,2,1))
mod4=arima(data,c(4,2,0))
mod5=arima(data,c(5,2,0))
mod3
mod4
mod5
mod3
kable(AIC(mod1))
kable(accuracy(mod1))
kable(AIC(mod1))
kable(summary(mod1))
kable(summary(mod1))
kable(accuracy(mod3))
kable(summary(mod1))
kable(summary(mod2))
kable(summary(mod1)$AIC)
kable(summary(mod1)$aic)
str(mod1)
kable(summary(mod1)$aicc)
str(mod1)
mod1$aicc
kable(mod1$aicc)
mod1$aicc
mod2$aicc
mod2=arima(data,c(5,2,0))
mod2$aicc
str(mod2)
mod2$aic
mod3$aic
mod2=arima(data,c(13,2,0))
mod3=arima(data,c(15,2,0))
mod4=arima(data,c(14,2,1))
mod5=arima(data,c(15,2,1))
mod6=arima(data,c(15,2,2))
mod1=arima(data,c(14,2,0))
data=usgdp
mod1=arima(data,c(14,2,0))
mod2=arima(data,c(13,2,0))
mod3=arima(data,c(15,2,0))
mod4=arima(data,c(14,2,1))
mod5=arima(data,c(15,2,1))
mod6=arima(data,c(15,2,2))
```
kable(accuracy(mod1))
kable(accuracy(mod2))
kable(accuracy(mod3))
kable(accuracy(mod4))
Box.test(mod5$res, type="Lj")   # p > 0.05, H0 neatmetamas, kad liekanos nekoreliuotos
mean(mod5$res)                  # vidurkis labai arti 0
mean(mod5$res)                  # vidurkis labai arti 0
shapiro.test(mod5$res)          # galime neatmesti H0, nes p > 0.05, liekanos normaliojo skirstinio
mean(mod5$res)                  # vidurkis labai arti 0
mod5$res
mean(mod5$res)                  # vidurkis labai arti 0
kable(accuracy(mod1))
kable(accuracy(mod2))
kable(accuracy(mod3))
kable(accuracy(mod4))
kable(accuracy(mod5))
kable(accuracy(mod6))
mod1$aic
mod2$aic
mod3$aic
mod4$aic
mod5$aic
mod6$aic
mod1=auto.arima(data)
mod1
kable(accuracy(mod1))
kable(accuracy(mod5))
mod3$aic
mod5$aic
mod1$aic
mod4=arima(data,c(15,2,0))
Box.test(mod4$res, type="Lj")   # p > 0.05, H0 neatmetamas, kad liekanos nekoreliuotos
mean(mod4$res)                  # vidurkis nėra arti 0
shapiro.test(mod4$res)          # galime neatmesti H0, nes p > 0.05, liekanos normaliojo skirstinio
t.test(mod6$res,mu=0)
t.test(mod1$res,mu=0)
t.test(mod2$res,mu=0)
mean(mod2$res)                  # vidurkis nėra arti 0
plot(forecast(mod6))
modETS=ets(wmurders)
modETS=ets(usgdp)
Box.test(modETS$res, type="Lj")   # p > 0.05, H0 neatmetamas, kad liekanos nekoreliuotos
mean(modETS$res)                  # vidurkis labai arti 0
shapiro.test(modETS$res)          # galime neatmesti H0, nes p > 0.05, liekanos normaliojo skirstinio
shapiro.test(modETS$res)          # galime neatmesti H0, nes p > 0.05, liekanos normaliojo skirstinio
Box.test(modETS$res, type="Lj")   # p > 0.05, H0 neatmetamas, kad liekanos nekoreliuotos
modETS
kable(accuracy(modETS))
kable(accuracy(mod6))
modETS
mod6
modETS$aic
modETS$aic
mod6$aic
?mcopper
data=mcopper
tsdisplay(data, plot.type="scatter")
lambda<-BoxCox.lambda(data)           #lambda skaičius randamas
plot(BoxCox(mcopper, lambda=lamba))   #transformuojamų duomenų grafikas
diffdata<-BoxCox(mcopper, lambda=lemda3)  #
lambda<-BoxCox.lambda(data)           #lambda skaičius randamas
plot(BoxCox(mcopper, lambda=lambda))   #transformuojamų duomenų grafikas
diffdata<-BoxCox(mcopper, lambda=lambda)  #
tsdisplay(data, plot.type="scatter")
plot(BoxCox(mcopper, lambda=lambda))   #transformuojamų duomenų grafikas
tsdisplay(diffdata, plot.type="scatter")
tsdisplay(data, plot.type="scatter")
tsdisplay(diffdata, plot.type="scatter")
tsdisplay(data, plot.type="scatter")
tsdisplay(diffdata, plot.type="scatter")
tsdisplay(data, plot.type="scatter")
tsdisplay(diffdata, plot.type="scatter")
lambda
auto.arima(diffdata)
auto.arima(diffdata)
nd=ndiffs(diffdata)
nd
``{r}
data=mcopper
tsdisplay(data, plot.type="scatter")
```
```{r}
lambda<-BoxCox.lambda(data)               #lambda skaičius randamas
transfdata<-BoxCox(mcopper, lambda=lambda)  #transformuojami duomenys
tsdisplay(transfdata, plot.type="scatter")  #transformuojamų duomenų grafikas
```
(b) fit a suitable ARIMA model to the transformed data using
auto.arima();
Randame ARIMA modelį su auto.arima funkcija diferencijuotiems duomenim:
```{r}
auto.arima(transfdata)
```
Gauname ARIMA(0,1,1)
(c) try some other plausible models by experimenting with the
orders chosen;
Sužinosime kiek reikia diferencijuoti, kad būtų stacionarūs duomenys (iš auto.arima matome, kad d=1, tiek pat kartų diferencijuoti nurodo ir "ndiffs" funkcija)
```{r}
nd=ndiffs(transfdata)
difftransfdata <- diff(transfdata,differences=nd)
```
Diferencijuotų duomenų ACF atrodo lyg sinusoidinis. O PACF grafike matomas 14-tas reikšmingas lag'as, o tolesni lag'ai nereikšmingi.
```{r}
data=mcopper
tsdisplay(data, plot.type="scatter")
lambda<-BoxCox.lambda(data)               #lambda skaičius randamas
transfdata<-BoxCox(mcopper, lambda=lambda)  #transformuojami duomenys
tsdisplay(transfdata, plot.type="scatter")  #transformuojamų duomenų grafikas
auto.arima(transfdata)
nd=ndiffs(transfdata)
difftransfdata <- diff(transfdata,differences=nd)
pacf(difftransfdata)
acf(difftransfdata)
pacf(difftransfdata)
acf(difftransfdata)
pacf(difftransfdata)
pacf(difftransfdata)
acf(difftransfdata)
pacf(difftransfdata)
